package scalan.sql

import java.lang.reflect.Method
import scalan._
import scalan.common.Lazy
import scala.reflect.runtime.universe._
import scalan.common.Default

package impl {
// Abs -----------------------------------
trait ItersAbs extends Scalan with Iters {
  self: ItersDsl with ScalanSql =>

  // single proxy for each type family
  implicit def proxyIter[Row](p: Rep[Iter[Row]]): Iter[Row] = {
    proxyOps[Iter[Row]](p)(scala.reflect.classTag[Iter[Row]])
  }

  // familyElem
  class IterElem[Row, To <: Iter[Row]](implicit _eRow: Elem[Row])
    extends EntityElem[To] {
    def eRow = _eRow
    lazy val parent: Option[Elem[_]] = None
    lazy val typeArgs = TypeArgs("Row" -> eRow)
    override def isEntityType = true
    override lazy val tag = {
      implicit val tagRow = eRow.tag
      weakTypeTag[Iter[Row]].asInstanceOf[WeakTypeTag[To]]
    }
    override def convert(x: Rep[Def[_]]) = {
      implicit val eTo: Elem[To] = this
      val conv = fun {x: Rep[Iter[Row]] => convertIter(x) }
      tryConvert(element[Iter[Row]], this, x, conv)
    }

    def convertIter(x: Rep[Iter[Row]]): Rep[To] = {
      x.selfType1 match {
        case _: IterElem[_, _] => x.asRep[To]
        case e => !!!(s"Expected $x to have IterElem[_, _], but got $e", x)
      }
    }

    override def getDefaultRep: Rep[To] = ???
  }

  implicit def iterElement[Row](implicit eRow: Elem[Row]): Elem[Iter[Row]] =
    cachedElem[IterElem[Row, Iter[Row]]](eRow)

  implicit case object IterCompanionElem extends CompanionElem[IterCompanionAbs] {
    lazy val tag = weakTypeTag[IterCompanionAbs]
    protected def getDefaultRep = Iter
  }

  abstract class IterCompanionAbs extends CompanionDef[IterCompanionAbs] with IterCompanion {
    def selfType = IterCompanionElem
    override def toString = "Iter"
  }
  def Iter: Rep[IterCompanionAbs]
  implicit def proxyIterCompanionAbs(p: Rep[IterCompanionAbs]): IterCompanionAbs =
    proxyOps[IterCompanionAbs](p)

  // single proxy for each type family
  implicit def proxyCursorIter[Row, K](p: Rep[CursorIter[Row, K]]): CursorIter[Row, K] = {
    proxyOps[CursorIter[Row, K]](p)(scala.reflect.classTag[CursorIter[Row, K]])
  }
  // familyElem
  class CursorIterElem[Row, K, To <: CursorIter[Row, K]](implicit _eRow: Elem[Row], _eK: Elem[K])
    extends IterElem[Row, To] {
    override def eRow = _eRow
    def eK = _eK
    override lazy val parent: Option[Elem[_]] = Some(iterElement(element[Row]))
    override lazy val typeArgs = TypeArgs("Row" -> eRow, "K" -> eK)
    override def isEntityType = true
    override lazy val tag = {
      implicit val tagRow = eRow.tag
      implicit val tagK = eK.tag
      weakTypeTag[CursorIter[Row, K]].asInstanceOf[WeakTypeTag[To]]
    }
    override def convert(x: Rep[Def[_]]) = {
      implicit val eTo: Elem[To] = this
      val conv = fun {x: Rep[CursorIter[Row, K]] => convertCursorIter(x) }
      tryConvert(element[CursorIter[Row, K]], this, x, conv)
    }

    def convertCursorIter(x: Rep[CursorIter[Row, K]]): Rep[To] = {
      x.selfType1 match {
        case _: CursorIterElem[_, _, _] => x.asRep[To]
        case e => !!!(s"Expected $x to have CursorIterElem[_, _, _], but got $e", x)
      }
    }

    override def getDefaultRep: Rep[To] = ???
  }

  implicit def cursorIterElement[Row, K](implicit eRow: Elem[Row], eK: Elem[K]): Elem[CursorIter[Row, K]] =
    cachedElem[CursorIterElem[Row, K, CursorIter[Row, K]]](eRow, eK)

  abstract class AbsTableCursorIter[Row]
      (tableName: String)(implicit eRow: Elem[Row])
    extends TableCursorIter[Row](tableName) with Def[TableCursorIter[Row]] {
    lazy val selfType = element[TableCursorIter[Row]]
  }
  // elem for concrete class
  class TableCursorIterElem[Row](val iso: Iso[TableCursorIterData[Row], TableCursorIter[Row]])(implicit override val eRow: Elem[Row])
    extends CursorIterElem[Row, Long, TableCursorIter[Row]]
    with ConcreteElem[TableCursorIterData[Row], TableCursorIter[Row]] {
    override lazy val parent: Option[Elem[_]] = Some(cursorIterElement(element[Row], LongElement))
    override lazy val typeArgs = TypeArgs("Row" -> eRow)

    override def convertCursorIter(x: Rep[CursorIter[Row, Long]]) = // Converter is not generated by meta
!!!("Cannot convert from CursorIter to TableCursorIter: missing fields List(tableName)")
    override def getDefaultRep = TableCursorIter(scalan.common.Default.defaultOf[String])
    override lazy val tag = {
      implicit val tagRow = eRow.tag
      weakTypeTag[TableCursorIter[Row]]
    }
  }

  // state representation type
  type TableCursorIterData[Row] = String

  // 3) Iso for concrete class
  class TableCursorIterIso[Row](implicit eRow: Elem[Row])
    extends EntityIso[TableCursorIterData[Row], TableCursorIter[Row]] with Def[TableCursorIterIso[Row]] {
    override def from(p: Rep[TableCursorIter[Row]]) =
      p.tableName
    override def to(p: Rep[String]) = {
      val tableName = p
      TableCursorIter(valueFromRep(tableName))
    }
    lazy val eFrom = element[String]
    lazy val eTo = new TableCursorIterElem[Row](self)
    lazy val selfType = new TableCursorIterIsoElem[Row](eRow)
    def productArity = 1
    def productElement(n: Int) = eRow
  }
  case class TableCursorIterIsoElem[Row](eRow: Elem[Row]) extends Elem[TableCursorIterIso[Row]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new TableCursorIterIso[Row]()(eRow))
    lazy val tag = {
      implicit val tagRow = eRow.tag
      weakTypeTag[TableCursorIterIso[Row]]
    }
    lazy val typeArgs = TypeArgs("Row" -> eRow)
  }
  // 4) constructor and deconstructor
  class TableCursorIterCompanionAbs extends CompanionDef[TableCursorIterCompanionAbs] {
    def selfType = TableCursorIterCompanionElem
    override def toString = "TableCursorIter"

    @scalan.OverloadId("fromFields")
    def apply[Row](tableName: String)(implicit eRow: Elem[Row]): Rep[TableCursorIter[Row]] =
      mkTableCursorIter(tableName)

    def unapply[Row](p: Rep[CursorIter[Row, Long]]) = unmkTableCursorIter(p)
  }
  lazy val TableCursorIterRep: Rep[TableCursorIterCompanionAbs] = new TableCursorIterCompanionAbs
  lazy val TableCursorIter: TableCursorIterCompanionAbs = proxyTableCursorIterCompanion(TableCursorIterRep)
  implicit def proxyTableCursorIterCompanion(p: Rep[TableCursorIterCompanionAbs]): TableCursorIterCompanionAbs = {
    proxyOps[TableCursorIterCompanionAbs](p)
  }

  implicit case object TableCursorIterCompanionElem extends CompanionElem[TableCursorIterCompanionAbs] {
    lazy val tag = weakTypeTag[TableCursorIterCompanionAbs]
    protected def getDefaultRep = TableCursorIter
  }

  implicit def proxyTableCursorIter[Row](p: Rep[TableCursorIter[Row]]): TableCursorIter[Row] =
    proxyOps[TableCursorIter[Row]](p)

  implicit class ExtendedTableCursorIter[Row](p: Rep[TableCursorIter[Row]])(implicit eRow: Elem[Row]) {
    def toData: Rep[TableCursorIterData[Row]] = isoTableCursorIter(eRow).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoTableCursorIter[Row](implicit eRow: Elem[Row]): Iso[TableCursorIterData[Row], TableCursorIter[Row]] =
    reifyObject(new TableCursorIterIso[Row]()(eRow))

  // 6) smart constructor and deconstructor
  def mkTableCursorIter[Row](tableName: String)(implicit eRow: Elem[Row]): Rep[TableCursorIter[Row]]
  def unmkTableCursorIter[Row](p: Rep[CursorIter[Row, Long]]): Option[(String)]

  abstract class AbsIndexCursorIter[Row, K]
      (tableName: String, indexName: String, columns: Array[(String, Boolean)], isUnique: Boolean)(implicit eRow: Elem[Row], eK: Elem[K])
    extends IndexCursorIter[Row, K](tableName, indexName, columns, isUnique) with Def[IndexCursorIter[Row, K]] {
    lazy val selfType = element[IndexCursorIter[Row, K]]
  }
  // elem for concrete class
  class IndexCursorIterElem[Row, K](val iso: Iso[IndexCursorIterData[Row, K], IndexCursorIter[Row, K]])(implicit override val eRow: Elem[Row], val eK: Elem[K])
    extends IterElem[Row, IndexCursorIter[Row, K]]
    with ConcreteElem[IndexCursorIterData[Row, K], IndexCursorIter[Row, K]] {
    override lazy val parent: Option[Elem[_]] = Some(iterElement(element[Row]))
    override lazy val typeArgs = TypeArgs("Row" -> eRow, "K" -> eK)

    override def convertIter(x: Rep[Iter[Row]]) = // Converter is not generated by meta
!!!("Cannot convert from Iter to IndexCursorIter: missing fields List(tableName, indexName, columns, isUnique)")
    override def getDefaultRep = IndexCursorIter(scalan.common.Default.defaultOf[String], scalan.common.Default.defaultOf[String], scalan.common.Default.defaultOf[Array[(String, Boolean)]], scalan.common.Default.defaultOf[Boolean])
    override lazy val tag = {
      implicit val tagRow = eRow.tag
      implicit val tagK = eK.tag
      weakTypeTag[IndexCursorIter[Row, K]]
    }
  }

  // state representation type
  type IndexCursorIterData[Row, K] = (String, (String, (Array[(String, Boolean)], Boolean)))

  // 3) Iso for concrete class
  class IndexCursorIterIso[Row, K](implicit eRow: Elem[Row], eK: Elem[K])
    extends EntityIso[IndexCursorIterData[Row, K], IndexCursorIter[Row, K]] with Def[IndexCursorIterIso[Row, K]] {
    override def from(p: Rep[IndexCursorIter[Row, K]]) =
      Pair(p.tableName, Pair(p.indexName, Pair(p.columns, p.isUnique)))
    override def to(p: Rep[(String, (String, (Array[(String, Boolean)], Boolean)))]) = {
      val Pair(tableName, Pair(indexName, Pair(columns, isUnique))) = p
      IndexCursorIter(valueFromRep(tableName), valueFromRep(indexName), valueFromRep(columns), valueFromRep(isUnique))
    }
    lazy val eFrom = pairElement(element[String], pairElement(element[String], pairElement(element[Array[(String, Boolean)]], element[Boolean])))
    lazy val eTo = new IndexCursorIterElem[Row, K](self)
    lazy val selfType = new IndexCursorIterIsoElem[Row, K](eRow, eK)
    def productArity = 2
    def productElement(n: Int) = (eRow, eK).productElement(n)
  }
  case class IndexCursorIterIsoElem[Row, K](eRow: Elem[Row], eK: Elem[K]) extends Elem[IndexCursorIterIso[Row, K]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new IndexCursorIterIso[Row, K]()(eRow, eK))
    lazy val tag = {
      implicit val tagRow = eRow.tag
      implicit val tagK = eK.tag
      weakTypeTag[IndexCursorIterIso[Row, K]]
    }
    lazy val typeArgs = TypeArgs("Row" -> eRow, "K" -> eK)
  }
  // 4) constructor and deconstructor
  class IndexCursorIterCompanionAbs extends CompanionDef[IndexCursorIterCompanionAbs] {
    def selfType = IndexCursorIterCompanionElem
    override def toString = "IndexCursorIter"
    @scalan.OverloadId("fromData")
    def apply[Row, K](p: Rep[IndexCursorIterData[Row, K]])(implicit eRow: Elem[Row], eK: Elem[K]): Rep[IndexCursorIter[Row, K]] =
      isoIndexCursorIter(eRow, eK).to(p)
    @scalan.OverloadId("fromFields")
    def apply[Row, K](tableName: String, indexName: String, columns: Array[(String, Boolean)], isUnique: Boolean)(implicit eRow: Elem[Row], eK: Elem[K]): Rep[IndexCursorIter[Row, K]] =
      mkIndexCursorIter(tableName, indexName, columns, isUnique)

    def unapply[Row, K](p: Rep[Iter[Row]]) = unmkIndexCursorIter(p)
  }
  lazy val IndexCursorIterRep: Rep[IndexCursorIterCompanionAbs] = new IndexCursorIterCompanionAbs
  lazy val IndexCursorIter: IndexCursorIterCompanionAbs = proxyIndexCursorIterCompanion(IndexCursorIterRep)
  implicit def proxyIndexCursorIterCompanion(p: Rep[IndexCursorIterCompanionAbs]): IndexCursorIterCompanionAbs = {
    proxyOps[IndexCursorIterCompanionAbs](p)
  }

  implicit case object IndexCursorIterCompanionElem extends CompanionElem[IndexCursorIterCompanionAbs] {
    lazy val tag = weakTypeTag[IndexCursorIterCompanionAbs]
    protected def getDefaultRep = IndexCursorIter
  }

  implicit def proxyIndexCursorIter[Row, K](p: Rep[IndexCursorIter[Row, K]]): IndexCursorIter[Row, K] =
    proxyOps[IndexCursorIter[Row, K]](p)

  implicit class ExtendedIndexCursorIter[Row, K](p: Rep[IndexCursorIter[Row, K]])(implicit eRow: Elem[Row], eK: Elem[K]) {
    def toData: Rep[IndexCursorIterData[Row, K]] = isoIndexCursorIter(eRow, eK).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoIndexCursorIter[Row, K](implicit eRow: Elem[Row], eK: Elem[K]): Iso[IndexCursorIterData[Row, K], IndexCursorIter[Row, K]] =
    reifyObject(new IndexCursorIterIso[Row, K]()(eRow, eK))

  // 6) smart constructor and deconstructor
  def mkIndexCursorIter[Row, K](tableName: String, indexName: String, columns: Array[(String, Boolean)], isUnique: Boolean)(implicit eRow: Elem[Row], eK: Elem[K]): Rep[IndexCursorIter[Row, K]]
  def unmkIndexCursorIter[Row, K](p: Rep[Iter[Row]]): Option[(String, String, Array[(String, Boolean)], Boolean)]

  registerModule(Iters_Module)
}

// Std -----------------------------------
trait ItersStd extends ScalanStd with ItersDsl {
  self: ItersDsl with ScalanSqlStd =>
  lazy val Iter: Rep[IterCompanionAbs] = new IterCompanionAbs {
  }

  case class StdTableCursorIter[Row]
      (override val tableName: String)(implicit eRow: Elem[Row])
    extends AbsTableCursorIter[Row](tableName) {
  }

  def mkTableCursorIter[Row]
    (tableName: String)(implicit eRow: Elem[Row]): Rep[TableCursorIter[Row]] =
    new StdTableCursorIter[Row](tableName)
  def unmkTableCursorIter[Row](p: Rep[CursorIter[Row, Long]]) = p match {
    case p: TableCursorIter[Row] @unchecked =>
      Some((p.tableName))
    case _ => None
  }

  case class StdIndexCursorIter[Row, K]
      (override val tableName: String, override val indexName: String, override val columns: Array[(String, Boolean)], override val isUnique: Boolean)(implicit eRow: Elem[Row], eK: Elem[K])
    extends AbsIndexCursorIter[Row, K](tableName, indexName, columns, isUnique) {
  }

  def mkIndexCursorIter[Row, K]
    (tableName: String, indexName: String, columns: Array[(String, Boolean)], isUnique: Boolean)(implicit eRow: Elem[Row], eK: Elem[K]): Rep[IndexCursorIter[Row, K]] =
    new StdIndexCursorIter[Row, K](tableName, indexName, columns, isUnique)
  def unmkIndexCursorIter[Row, K](p: Rep[Iter[Row]]) = p match {
    case p: IndexCursorIter[Row, K] @unchecked =>
      Some((p.tableName, p.indexName, p.columns, p.isUnique))
    case _ => None
  }
}

// Exp -----------------------------------
trait ItersExp extends ScalanExp with ItersDsl {
  self: ItersDsl with ScalanSqlExp =>
  lazy val Iter: Rep[IterCompanionAbs] = new IterCompanionAbs {
  }

  case class ExpTableCursorIter[Row]
      (override val tableName: String)(implicit eRow: Elem[Row])
    extends AbsTableCursorIter[Row](tableName)

  object TableCursorIterMethods {
    object eK {
      def unapply(d: Def[_]): Option[Rep[TableCursorIter[Row]] forSome {type Row}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[TableCursorIterElem[_]] && method.getName == "eK" =>
          Some(receiver).asInstanceOf[Option[Rep[TableCursorIter[Row]] forSome {type Row}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[TableCursorIter[Row]] forSome {type Row}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  def mkTableCursorIter[Row]
    (tableName: String)(implicit eRow: Elem[Row]): Rep[TableCursorIter[Row]] =
    new ExpTableCursorIter[Row](tableName)
  def unmkTableCursorIter[Row](p: Rep[CursorIter[Row, Long]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: TableCursorIterElem[Row] @unchecked =>
      Some((p.asRep[TableCursorIter[Row]].tableName))
    case _ =>
      None
  }

  case class ExpIndexCursorIter[Row, K]
      (override val tableName: String, override val indexName: String, override val columns: Array[(String, Boolean)], override val isUnique: Boolean)(implicit eRow: Elem[Row], eK: Elem[K])
    extends AbsIndexCursorIter[Row, K](tableName, indexName, columns, isUnique)

  object IndexCursorIterMethods {
  }

  def mkIndexCursorIter[Row, K]
    (tableName: String, indexName: String, columns: Array[(String, Boolean)], isUnique: Boolean)(implicit eRow: Elem[Row], eK: Elem[K]): Rep[IndexCursorIter[Row, K]] =
    new ExpIndexCursorIter[Row, K](tableName, indexName, columns, isUnique)
  def unmkIndexCursorIter[Row, K](p: Rep[Iter[Row]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: IndexCursorIterElem[Row, K] @unchecked =>
      Some((p.asRep[IndexCursorIter[Row, K]].tableName, p.asRep[IndexCursorIter[Row, K]].indexName, p.asRep[IndexCursorIter[Row, K]].columns, p.asRep[IndexCursorIter[Row, K]].isUnique))
    case _ =>
      None
  }

  object IterMethods {
    object map {
      def unapply(d: Def[_]): Option[(Rep[Iter[Row]], Rep[Row => B]) forSome {type Row; type B}] = d match {
        case MethodCall(receiver, method, Seq(f, _*), _) if receiver.elem.isInstanceOf[IterElem[_, _]] && method.getName == "map" =>
          Some((receiver, f)).asInstanceOf[Option[(Rep[Iter[Row]], Rep[Row => B]) forSome {type Row; type B}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Iter[Row]], Rep[Row => B]) forSome {type Row; type B}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object mapU {
      def unapply(d: Def[_]): Option[(Rep[Iter[Row]], Rep[((B, Row)) => Unit], Elem[B]) forSome {type Row; type B}] = d match {
        case MethodCall(receiver, method, Seq(f, eB, _*), _) if receiver.elem.isInstanceOf[IterElem[_, _]] && method.getName == "mapU" =>
          Some((receiver, f, eB)).asInstanceOf[Option[(Rep[Iter[Row]], Rep[((B, Row)) => Unit], Elem[B]) forSome {type Row; type B}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Iter[Row]], Rep[((B, Row)) => Unit], Elem[B]) forSome {type Row; type B}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object flatMap {
      def unapply(d: Def[_]): Option[(Rep[Iter[Row]], Rep[Row => Iter[B]]) forSome {type Row; type B}] = d match {
        case MethodCall(receiver, method, Seq(f, _*), _) if receiver.elem.isInstanceOf[IterElem[_, _]] && method.getName == "flatMap" =>
          Some((receiver, f)).asInstanceOf[Option[(Rep[Iter[Row]], Rep[Row => Iter[B]]) forSome {type Row; type B}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Iter[Row]], Rep[Row => Iter[B]]) forSome {type Row; type B}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object filter {
      def unapply(d: Def[_]): Option[(Rep[Iter[Row]], Rep[Row => Boolean]) forSome {type Row}] = d match {
        case MethodCall(receiver, method, Seq(f, _*), _) if receiver.elem.isInstanceOf[IterElem[_, _]] && method.getName == "filter" =>
          Some((receiver, f)).asInstanceOf[Option[(Rep[Iter[Row]], Rep[Row => Boolean]) forSome {type Row}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Iter[Row]], Rep[Row => Boolean]) forSome {type Row}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object isEmpty {
      def unapply(d: Def[_]): Option[Rep[Iter[Row]] forSome {type Row}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[IterElem[_, _]] && method.getName == "isEmpty" =>
          Some(receiver).asInstanceOf[Option[Rep[Iter[Row]] forSome {type Row}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[Iter[Row]] forSome {type Row}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object reduce {
      def unapply(d: Def[_]): Option[(Rep[Iter[Row]], Rep[((B, Row)) => B], Rep[Thunk[B]]) forSome {type Row; type B}] = d match {
        case MethodCall(receiver, method, Seq(f, init, _*), _) if receiver.elem.isInstanceOf[IterElem[_, _]] && method.getName == "reduce" =>
          Some((receiver, f, init)).asInstanceOf[Option[(Rep[Iter[Row]], Rep[((B, Row)) => B], Rep[Thunk[B]]) forSome {type Row; type B}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Iter[Row]], Rep[((B, Row)) => B], Rep[Thunk[B]]) forSome {type Row; type B}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object reduceU {
      def unapply(d: Def[_]): Option[(Rep[Iter[Row]], Rep[((B, Row)) => Unit], Rep[Thunk[B]]) forSome {type Row; type B}] = d match {
        case MethodCall(receiver, method, Seq(f, init, _*), _) if receiver.elem.isInstanceOf[IterElem[_, _]] && method.getName == "reduceU" =>
          Some((receiver, f, init)).asInstanceOf[Option[(Rep[Iter[Row]], Rep[((B, Row)) => Unit], Rep[Thunk[B]]) forSome {type Row; type B}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Iter[Row]], Rep[((B, Row)) => Unit], Rep[Thunk[B]]) forSome {type Row; type B}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object mapReduce {
      def unapply(d: Def[_]): Option[(Rep[Iter[Row]], Rep[Row => K], Rep[Row => String], Rep[Thunk[V]], Rep[((V, Row)) => V]) forSome {type Row; type K; type V}] = d match {
        case MethodCall(receiver, method, Seq(mapKey, packKey, newValue, reduceValue, _*), _) if receiver.elem.isInstanceOf[IterElem[_, _]] && method.getName == "mapReduce" =>
          Some((receiver, mapKey, packKey, newValue, reduceValue)).asInstanceOf[Option[(Rep[Iter[Row]], Rep[Row => K], Rep[Row => String], Rep[Thunk[V]], Rep[((V, Row)) => V]) forSome {type Row; type K; type V}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Iter[Row]], Rep[Row => K], Rep[Row => String], Rep[Thunk[V]], Rep[((V, Row)) => V]) forSome {type Row; type K; type V}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object mapReduceU {
      def unapply(d: Def[_]): Option[(Rep[Iter[Row]], Rep[Row => K], Rep[Row => String], Rep[Thunk[V]], Rep[((V, Row)) => Unit]) forSome {type Row; type K; type V}] = d match {
        case MethodCall(receiver, method, Seq(mapKey, packKey, newValue, reduceValue, _*), _) if receiver.elem.isInstanceOf[IterElem[_, _]] && method.getName == "mapReduceU" =>
          Some((receiver, mapKey, packKey, newValue, reduceValue)).asInstanceOf[Option[(Rep[Iter[Row]], Rep[Row => K], Rep[Row => String], Rep[Thunk[V]], Rep[((V, Row)) => Unit]) forSome {type Row; type K; type V}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Iter[Row]], Rep[Row => K], Rep[Row => String], Rep[Thunk[V]], Rep[((V, Row)) => Unit]) forSome {type Row; type K; type V}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object sort {
      def unapply(d: Def[_]): Option[(Rep[Iter[Row]], Rep[((Row, Row)) => Boolean]) forSome {type Row}] = d match {
        case MethodCall(receiver, method, Seq(comparator, _*), _) if receiver.elem.isInstanceOf[IterElem[_, _]] && method.getName == "sort" =>
          Some((receiver, comparator)).asInstanceOf[Option[(Rep[Iter[Row]], Rep[((Row, Row)) => Boolean]) forSome {type Row}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Iter[Row]], Rep[((Row, Row)) => Boolean]) forSome {type Row}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object sortBy {
      def unapply(d: Def[_]): Option[(Rep[Iter[Row]], Rep[((Row, Row)) => Int]) forSome {type Row}] = d match {
        case MethodCall(receiver, method, Seq(comparator, _*), _) if receiver.elem.isInstanceOf[IterElem[_, _]] && method.getName == "sortBy" =>
          Some((receiver, comparator)).asInstanceOf[Option[(Rep[Iter[Row]], Rep[((Row, Row)) => Int]) forSome {type Row}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Iter[Row]], Rep[((Row, Row)) => Int]) forSome {type Row}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object join {
      def unapply(d: Def[_]): Option[(Rep[Iter[Row]], RIter[B], Rep[Row => Key], Rep[B => Key], Rep[B => B]) forSome {type Row; type B; type Key}] = d match {
        case MethodCall(receiver, method, Seq(other, thisKey, otherKey, cloneOther, _*), _) if receiver.elem.isInstanceOf[IterElem[_, _]] && method.getName == "join" =>
          Some((receiver, other, thisKey, otherKey, cloneOther)).asInstanceOf[Option[(Rep[Iter[Row]], RIter[B], Rep[Row => Key], Rep[B => Key], Rep[B => B]) forSome {type Row; type B; type Key}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Iter[Row]], RIter[B], Rep[Row => Key], Rep[B => Key], Rep[B => B]) forSome {type Row; type B; type Key}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    // WARNING: Cannot generate matcher for method `toArray`: Method's return type Arr[Row] is not a Rep

    object materialize {
      def unapply(d: Def[_]): Option[(Rep[Iter[Row]], Rep[Row => Row]) forSome {type Row}] = d match {
        case MethodCall(receiver, method, Seq(f, _*), _) if receiver.elem.isInstanceOf[IterElem[_, _]] && method.getName == "materialize" =>
          Some((receiver, f)).asInstanceOf[Option[(Rep[Iter[Row]], Rep[Row => Row]) forSome {type Row}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Iter[Row]], Rep[Row => Row]) forSome {type Row}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object IterCompanionMethods {
    object empty {
      def unapply(d: Def[_]): Option[Unit forSome {type Row}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem == IterCompanionElem && method.getName == "empty" =>
          Some(()).asInstanceOf[Option[Unit forSome {type Row}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Unit forSome {type Row}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }
}

object Iters_Module extends scalan.ModuleInfo {
  val dump = "H4sIAAAAAAAAAL1XT2hcRRif3WSz/2IboxULimm6VfHPbrRKhSAlTbaadpuEvMRKLJXZ92bTV+e9eZmZjbseqngoUsWDiAfBQ0HxUgrizUIRWkFEBL169lQrpQeLB8Vv5v3dZF9iCzWH4b15335/fr/fN/PlwnWUExw9KkxMsVt1iMRVQz9PCVkx6q60ZfcYs9qUzJDWz09+y0rvfjCXRSMraOgUFjOCrqCi/1DveNGzIa0GKmLXJEIyLiTa09ARaiajlJjSZm7Ndpy2xE1Kag1byMkGGmwyq7uGzqBMA42YzDU5kcSYplgIIoL9AlEZ2dF7Ub935704hltTVdQSVSxxbEtIH2KM+PaLxDO6LnO7jkQ7gtTmPZUW2JRJx4MaZh2P6jADDZS3HY9xGUbNQ4RTzApfB10MG2i0cRqv4xpEXa0ZktvuqnLmYfMNvErmwESZD0INgtDWUtcjgfOykFZPvI6HEAJWntWJVWPMqhFmVYVZxSDcxtR+C6uPC5x1usj/ywwg1PHAxVPbuAg9kLprVc6dMF+7ZZSdrPpxR6WS1wkNgaNHUhSi6QFsv1/8SNx86fyBLCqtoJItpppCcmzKpAwCuMrYdZnUOUcIYr4KDI6nMaijTIHNBpkUTeZ42AVPAZbDQBS1TVsqY7U3HNCTgn1eeiQ0zXS8TFTvWEq9WkvTmNKFa7uf3vd7/dUsyvaGKIJLA5qBh04lKk23uWB8VhIeBFDrTokGFtmbPs4c7U2L6JEFbjug+nXy/JVLyzcuz+V00FGLtHCbylcwbRNfcEEKcToqenaCSthl/udiJ17zWxQaQf7YtT+s7ybQiWxEVFDXf9MGuBh94dNv9pGFi1lUWNGtdJjiVa0SxcQMEeYKKrB1wv39/Dqm6qmvUvJB0QF/SeAHAHiJxlJPAY8oViZ1d2XC8st+g8wxl1QOL1T+NH74+ILSP0fD/hf/WPjHPvD3rztaUreGBI5VB6me1nntApDHxyUailkIAFbLHm2zO8H8Q5kwA/0d2CEghFAUg3VKnBSdJBmUaOeSSiMWVxxN0fJwuqCAlAcWG/fT6wcvZ1HuCMq1AG/RQLkma7tW2EtwBkvSkYfCvUwv3tA7mGMnlIN/8owhnYROdlPe2rSc6a1tcIu22CzYTVCiDVDG1KiNvSlGtmuRzjZGeTg1244rwqxyU5zj7raqB3iX2h4lz1366+R777zs6b7ZdCj4buLoIKFcC1MBCs4fYowS7CaL759hwRbLrr3W1lXM3nXZ9XeSJUe3cJE52k+3swr+/rpV6zNbaindpE+w7ekKhoOvzp7ddePz1+/TF1ihaUsHe5WJ27i+wtvmLl5PaAM9kPad91JPR0UW6kws+SefwRxy7/hN++T596UWcabTO+TMN0/DUDGp/YxpPwQlHG1wrImCs/MeleN0EhifPi9I//bEkGCZoDsHIzXb0v+iUrW2Yv9rQEI1Ra8zxKSYE0uNi8SBcdZX4v5PDh4/8uDxZU3UsKWN/C/Rldh/+D6GvUk9Kj6+xagIRpW648G/AvCw/+qLv7z945df6LswRgwOMA24DPTjVsUajcoZTynHCAQPUj5z67O5J376+jc93JRU68Cl7EZDd3Ko6WW1oOPCCB0DD7tFP4qxRhNwgypUiwVpqfWcWj78F4vigm0IDQAA"
}
}

