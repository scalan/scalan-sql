package scalan.sql

import java.lang.reflect.Method
import scalan._
import scalan.sql.parser.SqlAST.{Index, SortDirection, Table}
import scala.reflect.runtime.universe.{WeakTypeTag, weakTypeTag}
import scalan.meta.ScalanAst._

package impl {
// Abs -----------------------------------
trait DatabasesAbs extends Scalan with Databases {
  self: DatabasesDsl with ScalanSql =>

  // single proxy for each type family
  implicit def proxyDatabase[S <: SSchema](p: Rep[Database[S]]): Database[S] = {
    proxyOps[Database[S]](p)(scala.reflect.classTag[Database[S]])
  }

  // familyElem
  class DatabaseElem[S <: SSchema, To <: Database[S]](implicit _eS: Elem[S])
    extends EntityElem[To] {
    def eS = _eS
    lazy val parent: Option[Elem[_]] = None
    lazy val typeArgs = TypeArgs("S" -> (eS -> scalan.util.Invariant))
    override lazy val tag = {
      implicit val tagS = eS.tag
      weakTypeTag[Database[S]].asInstanceOf[WeakTypeTag[To]]
    }
    override def convert(x: Rep[Def[_]]) = {
      implicit val eTo: Elem[To] = this
      val conv = fun {x: Rep[Database[S]] => convertDatabase(x) }
      tryConvert(element[Database[S]], this, x, conv)
    }

    def convertDatabase(x: Rep[Database[S]]): Rep[To] = {
      x.selfType1 match {
        case _: DatabaseElem[_, _] => x.asRep[To]
        case e => !!!(s"Expected $x to have DatabaseElem[_, _], but got $e", x)
      }
    }

    override def getDefaultRep: Rep[To] = ???
  }

  implicit def databaseElement[S <: SSchema](implicit eS: Elem[S]): Elem[Database[S]] =
    cachedElem[DatabaseElem[S, Database[S]]](eS)

  implicit case object DatabaseCompanionElem extends CompanionElem[DatabaseCompanionAbs] {
    lazy val tag = weakTypeTag[DatabaseCompanionAbs]
    protected def getDefaultRep = Database
  }

  abstract class DatabaseCompanionAbs extends CompanionDef[DatabaseCompanionAbs] {
    def selfType = DatabaseCompanionElem
    override def toString = "Database"
  }
  def Database: Rep[DatabaseCompanionAbs]
  implicit def proxyDatabaseCompanionAbs(p: Rep[DatabaseCompanionAbs]): DatabaseCompanionAbs =
    proxyOps[DatabaseCompanionAbs](p)

  abstract class AbsDatabaseImpl[S <: SSchema]
      (connectionString: Rep[String])(implicit eS: Elem[S])
    extends DatabaseImpl[S](connectionString) with Def[DatabaseImpl[S]] {
    lazy val selfType = element[DatabaseImpl[S]]
  }
  // elem for concrete class
  class DatabaseImplElem[S <: SSchema](val iso: Iso[DatabaseImplData[S], DatabaseImpl[S]])(implicit override val eS: Elem[S])
    extends DatabaseElem[S, DatabaseImpl[S]]
    with ConcreteElem[DatabaseImplData[S], DatabaseImpl[S]] {
    override lazy val parent: Option[Elem[_]] = Some(databaseElement(element[S]))
    override lazy val typeArgs = TypeArgs("S" -> (eS -> scalan.util.Invariant))

    override def convertDatabase(x: Rep[Database[S]]) = // Converter is not generated by meta
!!!("Cannot convert from Database to DatabaseImpl: missing fields List(connectionString)")
    override def getDefaultRep = DatabaseImpl("")
    override lazy val tag = {
      implicit val tagS = eS.tag
      weakTypeTag[DatabaseImpl[S]]
    }
  }

  // state representation type
  type DatabaseImplData[S <: SSchema] = String

  // 3) Iso for concrete class
  class DatabaseImplIso[S <: SSchema](implicit eS: Elem[S])
    extends EntityIso[DatabaseImplData[S], DatabaseImpl[S]] with Def[DatabaseImplIso[S]] {
    override def from(p: Rep[DatabaseImpl[S]]) =
      p.connectionString
    override def to(p: Rep[String]) = {
      val connectionString = p
      DatabaseImpl(connectionString)
    }
    lazy val eFrom = element[String]
    lazy val eTo = new DatabaseImplElem[S](self)
    lazy val selfType = new DatabaseImplIsoElem[S](eS)
    def productArity = 1
    def productElement(n: Int) = eS
  }
  case class DatabaseImplIsoElem[S <: SSchema](eS: Elem[S]) extends Elem[DatabaseImplIso[S]] {
    def getDefaultRep = reifyObject(new DatabaseImplIso[S]()(eS))
    lazy val tag = {
      implicit val tagS = eS.tag
      weakTypeTag[DatabaseImplIso[S]]
    }
    lazy val typeArgs = TypeArgs("S" -> (eS -> scalan.util.Invariant))
  }
  // 4) constructor and deconstructor
  class DatabaseImplCompanionAbs extends CompanionDef[DatabaseImplCompanionAbs] {
    def selfType = DatabaseImplCompanionElem
    override def toString = "DatabaseImpl"

    @scalan.OverloadId("fromFields")
    def apply[S <: SSchema](connectionString: Rep[String])(implicit eS: Elem[S]): Rep[DatabaseImpl[S]] =
      mkDatabaseImpl(connectionString)

    def unapply[S <: SSchema](p: Rep[Database[S]]) = unmkDatabaseImpl(p)
  }
  lazy val DatabaseImplRep: Rep[DatabaseImplCompanionAbs] = new DatabaseImplCompanionAbs
  lazy val DatabaseImpl: DatabaseImplCompanionAbs = proxyDatabaseImplCompanion(DatabaseImplRep)
  implicit def proxyDatabaseImplCompanion(p: Rep[DatabaseImplCompanionAbs]): DatabaseImplCompanionAbs = {
    proxyOps[DatabaseImplCompanionAbs](p)
  }

  implicit case object DatabaseImplCompanionElem extends CompanionElem[DatabaseImplCompanionAbs] {
    lazy val tag = weakTypeTag[DatabaseImplCompanionAbs]
    protected def getDefaultRep = DatabaseImpl
  }

  implicit def proxyDatabaseImpl[S <: SSchema](p: Rep[DatabaseImpl[S]]): DatabaseImpl[S] =
    proxyOps[DatabaseImpl[S]](p)

  implicit class ExtendedDatabaseImpl[S <: SSchema](p: Rep[DatabaseImpl[S]])(implicit eS: Elem[S]) {
    def toData: Rep[DatabaseImplData[S]] = isoDatabaseImpl(eS).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoDatabaseImpl[S <: SSchema](implicit eS: Elem[S]): Iso[DatabaseImplData[S], DatabaseImpl[S]] =
    reifyObject(new DatabaseImplIso[S]()(eS))

  // 6) smart constructor and deconstructor
  def mkDatabaseImpl[S <: SSchema](connectionString: Rep[String])(implicit eS: Elem[S]): Rep[DatabaseImpl[S]]
  def unmkDatabaseImpl[S <: SSchema](p: Rep[Database[S]]): Option[(Rep[String])]

  registerModule(Databases_Module)
}

// Std -----------------------------------
trait DatabasesStd extends ScalanStd with DatabasesDsl {
  self: DatabasesDsl with ScalanSqlStd =>

  lazy val Database: Rep[DatabaseCompanionAbs] = new DatabaseCompanionAbs {
  }

  case class StdDatabaseImpl[S <: SSchema]
      (override val connectionString: Rep[String])(implicit eS: Elem[S])
    extends AbsDatabaseImpl[S](connectionString) {
  }

  def mkDatabaseImpl[S <: SSchema]
    (connectionString: Rep[String])(implicit eS: Elem[S]): Rep[DatabaseImpl[S]] =
    new StdDatabaseImpl[S](connectionString)
  def unmkDatabaseImpl[S <: SSchema](p: Rep[Database[S]]) = p match {
    case p: DatabaseImpl[S] @unchecked =>
      Some((p.connectionString))
    case _ => None
  }
}

// Exp -----------------------------------
trait DatabasesExp extends ScalanExp with DatabasesDsl {
  self: DatabasesDsl with ScalanSqlExp =>

  lazy val Database: Rep[DatabaseCompanionAbs] = new DatabaseCompanionAbs {
  }

  case class ExpDatabaseImpl[S <: SSchema]
      (override val connectionString: Rep[String])(implicit eS: Elem[S])
    extends AbsDatabaseImpl[S](connectionString)

  object DatabaseImplMethods {
  }

  def mkDatabaseImpl[S <: SSchema]
    (connectionString: Rep[String])(implicit eS: Elem[S]): Rep[DatabaseImpl[S]] =
    new ExpDatabaseImpl[S](connectionString)
  def unmkDatabaseImpl[S <: SSchema](p: Rep[Database[S]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: DatabaseImplElem[S] @unchecked =>
      Some((p.asRep[DatabaseImpl[S]].connectionString))
    case _ =>
      None
  }

  object DatabaseMethods {
  }
}

object Databases_Module extends scalan.ModuleInfo {
  val dump = "H4sIAAAAAAAAALVWTWwbRRQe20lsx1YJQSlBIiIYl3/sQouKZAEKtQOt3MR0mxbcqmi8O3a2zM5OdsbumkO5VQJuCHFA4lAE4hJVQlwQSFwACSHUA1fOnFqqqgcqIYF4M/vjdVU37QEfRrszz+/n+773Zrf/RNPCQ48KE1PMKg6RuGLo5xUhy0aDSVsOj7hWn5I66Z5+7bO/Tzrv3Z9Gc200s4lFXdA2ygcPDZ/Hz4a0miiPmUmEdD0h0cNNHaFqupQSU9ouq9qO05e4Q0m1aQtZa6KpjmsNt9A5lGqiOdNlpkckMQ5SLAQR4X6OqIzs+D2v34frfBSDVVUV1UQVxzxsS0gfYswF9kcJN4bMZUNHol1hautcpQU2BeJzqOGQw6kOk2mirO1w15NR1CxE2HSt6HWKYdhA880zeICrELVXNaRns55yxrH5Nu6RNTBR5lNQgyC0e2zISei8IKQ1Fs/nCCFg5TmdWGWEWSXGrKIwKxvEszG138HqsOW5/hAFv1QGIZ+Di6d3cBF5IA1mld8/ZZ68YRSctPqzr1LJ6oRmwNFDExSi6QFsfz76obj+6oUDaTTbRrO2WOkI6WFTJmUQwlXAjLlS5xwjiL0eMFiaxKCOsgI2N8kkb7oOxww8hVgWgShqm7ZUxmqvGNIzAfus5CQyTfk8Fde7PKFeraWDmNLW5Qee2XOl8UYapcdD5MGlAc3gRU4lytUxQI5DGc/o9R6JUobGWC15f7RmbxM+BuKxy1etn/aiU+kYvjDanTEGLuZf+OTbPaR1MY1ybS3wVYp7mjuFT50Is41y7oB4wX52gKl6uiV/WYt0cZ/KENUkHBmAQ6Llib3JicKqpjWfisovBLJdcxkpr7bKfxm/fLStVOmhYnASNOu/9oF/ft/VlVqwUg8NFsg86L8I6Az0e4zLI5OY5aTl2Q5MlwF5/ofvNq59vzatyZ0PizuOaZ8EjsPaRnWq8OlSSaKZkcEYp2pZ0jksJESwmIqK1ufggxhR0lMNSpwdBSNRMRKXGiCjMKrUpcmlggDevGJVFq8unU2jmcNougvciiaa7rh9ZkXdBIBK4stXor3UOLfQPdjDTjycBximCXS7RLsjvvvSptXj4X7AMvyW1XibDag0XIfcW7pun77wgdRqTvnjs3S9cwZIremCH4ygyBqGuUkcHAOSjeEB17vDwlX0yiEW5CXLT32zfda+9MSq1ksSxR2bJrpCvjp/fuHa52/dp8dcrmNLB/Py3rsYctFM+h+HGBoXTQbSHt+5u3GUT9wECyO4tdKSsy0pPbU+G1Ot3vbfAXFqqd0c+KWR3/1AUGUCQXViUuwRSzUBceCWD6Df9/HLJw4vntjQwipa2ig4iWfSrb9JjmBe0zfo47e5QcGo3HA4fCHBw74fX/zt3V+//CIWV1RdPoZbhppnFbFF45JKE0oyQpaBv3M3Pl178tLXf+h5NKv0ApORxd8jyTk0zmk8HNRX2YhHOMkHkYwtmmAdpo7SVoKx19Wy8R+P7SYvJwoAAA=="
}
}

